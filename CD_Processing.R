#' CD_Processing
#' This file contains several utility functions that process data based on from CD phenotying file pipelines
#' maintly handel the input of CD files by whole directory
#' @import dplyr
if(!require('dplyr')){stop("Package 'dplyr' could not be loaded")}
source('LineageProcessing.R')

#' CD_In: Function to import CD data 
#' @param directory the directory (folder) directly containing CD files
#' @param AuxInfor if loading AuxInfo files from this directory
#' @param TIME if loading TIME file from this directory and correct the times in CD files, pass "corrected" if the time is already corrected and no need to lead a TIME file
#' @param blotCorrected if the time in CD is already corrected
#' @param positioned if the nucleus positions are aligned in this CD
#' 
#' @return a list of DataFrame's, each element in the list is a DataFrame created by reading each CD file
#' @export
#' @examples
CD_In<-function(directory, AuxInfo = FALSE, TIME = FALSE, blotCorrected = FALSE, positioned = FALSE, prefix = "CD"){
  searchTerm = paste0("^", prefix, ".+\\.csv$")
  CDfiles <- list.files(directory, pattern=searchTerm)
  searchTerm = paste0("^", prefix, "(.*)\\.csv$")
  embNames <- gsub(searchTerm, "\\1", CDfiles)
  CDDataL <- list()
  CDDataL[['CD']] <- list()
  if(AuxInfo){ #All AuxInfo.csv files will be bind into 1 dataFrame with name 'embryoInfo'
    AuxInfo.path <- paste0(directory,embNames,'AuxInfo.csv')
    embryoInfo <- list()
    embryoInfo <- lapply(AuxInfo.path, read.csv) |> bind_rows()
    CDDataL[['embryoInfo']] <- embryoInfo
  }
  else{
    CDDataL[['embryoInfo']] <- data.frame(emb = embNames, name = embNames)
  }
  CDDataL[['CD']] <- embNames|>lapply(function(emb){
    CD.Path <- paste0(directory,prefix,emb,'.csv')
    CDDat <- read.csv(CD.Path)
    if(TIME==T){ #modify the time attributes
      TIME.path <- paste0(directory,'TIME',emb,'.csv')
      print("getting time data from: ")
      print(TIME.path)
      TIME <- read.table(TIME.path, header = F)[,2:3]
      colnames(TIME)<-c("time","realTime")
      CDDat <- merge(CDDat, TIME, by = "time", all.x = TRUE)
      CDDat$time <- CDDat$realTime/60
      CDDat$realTime <- NULL
    }
    CDDat
  })
  names(CDDataL[['CD']]) <- embNames
  if(TIME==T | TIME=='corrected'){CDDataL[["timeCorrected"]] <- TRUE}
  else{CDDataL[["timeCorrected"]] <- FALSE}
  CDDataL[["blotCorrected"]] <- blotCorrected
  CDDataL[["positioned"]] <- positioned
  
  return(CDDataL)
}

#' trimCD drop the provided columns from all imported CD data
#'
#' @param CDDataL the list of CD Data generated by function `CDfiles`
#' @param drops names of columns to drop
#' 
#' @export
#' @return the CDDataL
trimCD <- function(CDDataL, drops){
  CDDataL[['CD']] <- lapply(CDDataL[['CD']], function(L){L[,!names(L) %in% drops]})
  return(CDDataL)
}


#' plotBlotLine plots the averaged blot value across each timepoint for selected cells/lineages from all CD data available
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param alignCell the cell used to find common time point to align across embryos
#' @param cells (list of) exact cell names to extract
#' @param lineages (list of) mother cell names of lineages to extract
#' @param excludeCD (list of) CD names to exclude
#' @param colorGroup the embryo attribute by which we assign color to its corresponding figure curve, use embryo name by default
#' @param color_palette a named vector that map each possible colorGroup value to a color, use NULL to autogenerate a color palette by colorGroup
#' @param xrange a list in format list(min,max) to define range of x axis
#' @param yrange a list in format list(min,max) to define range of y axis
#' @return a single plotly line plot with each line the (average) blot vs time for each embryo 
#' @export
plotBlotLine <- function(CDDataL, title, aligningCell, alignTime = "mean", 
                         cells=NULL, lineages=NULL, excludeCD = NULL, 
                         colorGroup = "name", color_palette = NULL,
                         xrange = list(NULL, NULL), yrange = list(NULL, NULL)){
  embNames <- CDDataL[['embryoInfo']]$name
  color_by <- colorGroup
  if(colorGroup=="name"){colorGroup <- embNames}
  else if(colorGroup=='orientation'){colorGroup <- CDDataL[['embryoInfo']]$axis}
  blotData <- getCells(CDDataL, includeCD = embNames, cells = cells, lineages = lineages, excludeCD = excludeCD) 
  if(alignTime!="NO"){
    blotData <- blotData|> 
      alignTime(alignCell = aligningCell, alignBlot = "mean", alignTime = alignTime)
  }
  blotData <- blotData|>lapply(timeAvg, attribute = "blot")
  library("plotly",warn.conflicts = F)
  library('RColorBrewer',warn.conflicts = F)
  fig <- plot_ly()
  if(!color_palette|>is.character()){#generate a color palette if none is delivered
    unique_colors <- unique(colorGroup)
    color_palette <- colorRampPalette(brewer.pal(9, "RdBu"))(length(unique_colors))|>setNames(unique_colors)
  }
  for(i in seq_along(blotData)){
    traceName <- embNames[i]
    colorThis <- colorGroup[i]
    if(color_by!="name"){traceName=paste0(colorThis, " ", traceName)}
    fig <- fig|>add_trace(data = blotData[[i]], x = ~time, y = ~blot, 
                          type = 'scatter', mode = 'lines', 
                          name = traceName, 
                          line = list(color = color_palette[colorThis]), 
                          legendgroup = colorThis)
  }
  fig <- fig|>
    layout(xaxis = list(title = "Time (min)", range = xrange),
           yaxis = list(title = "Blot", range = yrange), 
           annotations = list(text = title, 
                              xref = "paper", yref = "paper", yanchor = "bottom", xanchor = "center",
                              align = "center", x = 0.5, y = 1, showarrow = FALSE)
    )
  return(fig)
}

#' getCells extract the data of given cells from each CD file
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param includeCD the embryos/CD file name to be extracted
#' @param excludeCD the embryos/CD file name to be avoid (will override `include`)
#' @param cells (list of) exact cell names to extract
#' @param lineages (list of) mother cell name of lineage to extract
#' @param dataReturn whether this function return the data (TRUE) or index (FALSE) of selected cells
#' @return a list of dataframes with the cell data, indexed by CD file embryo names
#' @export
getCells <- function(
    CDDataL, includeCD = NaN, excludeCD = NULL, cells=NULL, lineages=NULL, times = "ALL", dataReturn = TRUE){
  if (!is.character(includeCD)) {includeCD<-CDDataL[['embryoInfo']]$name} 
  embryos <- setdiff(includeCD, excludeCD) #exclude have higher priority than include
  CDs <- CDDataL[["CD"]][embryos]
  CDs <- CDs %>% lapply(grepCells, cells=cells, lineages=lineages, times=times, dataReturn = dataReturn)
  CDs|>setNames(embryos)
  return(CDs)
}



#' depthCorrectionParm: get the depth (z) correction parameters based on the sample data
#' use an exponential model: `blot = blotReal*(e^(a*z)*b)` (1)
#' (2): `blot/blotReal = e^(a*z) * b`
#' (3): `ln(blot/blotReal) = a*z + b`
#' Assuming the real blot is the same across cells at the same timepoint, we 
#' will make the mean of the same cell for each timepoint the `blotReal`
#'
#' @param CDDataL the list of CD Data generated by function `CD_In`
#' @param cells array of cell names to be considered for depth correction
#' @param lineages array of lineages mother cell names to be considered for depth correction
#' @param alignAt the cell name by which all embryo time will be aligned at its end, and its end time will become 0 after alignment
#' @param startT time after alignment (as frame number), only data after this time point will be considered in fitting model
#' @param endT time after alignment (as frame number), only data before this time point will be considered
#' @param exc_zMin excitation at z=1
#' @param exc_zMax excitation at maximum z
#' @param zMax maximum z
#' @return the regression model from fitting
#' @export
depthCorrectionParm <- function(
    CDDataL, cell=NULL, lineage=NULL, alignAt, startT=0, endT=Inf, exc_zMin, exc_zMax, zMax){
  excStep_z <- (exc_zMax - exc_zMin)/zMax
  embryoNames <- CDDataL[["embryoInfo"]]$name
  controlblots <- CDDataL[["CD"]]|> #increase all blotvalues by a baseline to make most values > 0
    lapply(function(df){min(df$blot)}) |> unlist() |> mean()
  cellsToFit <- CDDataL|>
    trimCD(c("none", 'global', 'gweight', 'size', 'cellTime', 'x', "y"))|>
    getCells(cells = cell, lineages = lineage)
  cellsToFit <- embryoNames|> 
    lapply(function(embryo){
      df <- cellsToFit[[embryo]]
      df$blot <- df$blot - controlblots
      df[df$blot<=10, 'blot'] <- 10
      df$blot <- df$blot/((df$z-1)*excStep_z+exc_zMin) #correct for excitation
      df})
  names(cellsToFit)<-embryoNames
  cellsToFit <- cellsToFit|>alignTime(alignCell = alignAt, alignTime = 0)
  dataToFit <- cellsToFit|>
    aggEmbryos(labelEmbryo = F)|>
    select(c("cell","time","z","blot"))
  if(CDDataL[['timeCorrected']]){dataToFit$time <- dataToFit$time%/%1.5} #bundle cell times into 1.5minute bins
  blotByDepth <- dataToFit[dataToFit$time>=startT & dataToFit$time<=endT,]|>
    group_by(time, cell)|>mutate(blot = blot/mean(blot))|>
    group_by(time, z)|>summarize(blot = mean(blot))
  model <- lm(log(blot)~z,data = blotByDepth)
  return(model)
}

dataCorrection <- function(
    CDDataL, cell=NULL, lineage=c("AB","P1"), alignAt=NaN, startT=0, endT=Inf, model, zMax, exc_zMin, exc_zMax){
  excStep_z <- (exc_zMax - exc_zMin)/zMax
  meanExc <- (exc_zMin+exc_zMax)/2
  factorA <- model[["coefficients"]][["z"]]
  factorB <- model[["coefficients"]][["(Intercept)"]]
  dataIndex <- CDDataL|>getCells(cells = cell, lineages = lineage, dataReturn = F)
  embryos <- CDDataL[["embryoInfo"]][["name"]]
  
  controlblots <- CDDataL[["CD"]]|> 
    lapply(function(df){min(df$blot)})
  baseBlot <- mean(unlist(controlblots))
  CDDataL[["CD"]] <- embryos|>lapply(function(embryo){
    df <- CDDataL[["CD"]][[embryo]]
    thisCells <- dataIndex[[embryo]]
    minBlot <- df$blot |> min()
    df$blot <- df$blot - baseBlot
    df[df$blot<=1, 'blot'] <- 1
    excitation <- (df[thisCells,'z']-1)*excStep_z+exc_zMin
    depthFactor <- exp(df[thisCells,'z']*factorA+factorB)
    df[thisCells,'blot'] <- df[thisCells,'blot']/depthFactor/excitation*meanExc
    df
  })
  names(CDDataL[["CD"]]) <- embryos
  if(is.character(alignAt)){CDDataL[["CD"]] <- CDDataL[["CD"]]|>alignTime(alignCell = alignAt, alignBlot = "mean")}
  return(CDDataL)
}

findCell <- function(CDDataL, cellName){
  out <- lapply(CDDataL[["CD"]], function(L){L[L$cell==cellName,]})
  out
}

Emb_drop <- function(CDDataL, dropEmb=NaN){
  embryoNames <- CDDataL[["embryoInfo"]]$name
  embryoNames <- embryoNames[!embryoNames %in% dropEmb]
  CDs <- CDDataL[["CD"]][embryoNames]
  embInfo <- CDDataL[["embryoInfo"]]
  embInfo <- embInfo[embInfo$name %in% embryoNames, ]
  newDat <- list()
  newDat[["CD"]] <- CDs
  newDat[["embryoInfo"]] <- embInfo
  newDat[["timeCorrected"]] <- CDDataL[["timeCorrected"]]
  return(newDat)
}